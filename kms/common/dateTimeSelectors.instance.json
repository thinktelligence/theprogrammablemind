{
  "configs": [
    {
      "operators": [
        "([dateTimeSelector] (onDate) (atTime))",
        "((day_dates/*) [dayOfMonth|of] (month_dates/*))",
        "((day_dates/*) [dayAfterDate|after] (afterDateValue_dates/*))"
      ],
      "bridges": [
        {
          "id": "dayOfMonth",
          "after": [
            "article"
          ],
          "isA": [
            "onDateValue_dates"
          ],
          "before": [
            "verb",
            "onDate_dates"
          ],
          "bridge": "{ ...next(operator), day: before[0], month: after[0], operator: operator, interpolate: '${day} ${operator} ${month}' }",
          "check": [
            "day",
            "month"
          ]
        },
        {
          "id": "dayAfterDate",
          "after": [
            "article",
            "monthDayYear_dates"
          ],
          "isA": [
            "onDateValue_dates"
          ],
          "before": [
            "verb",
            "afterDate_dates"
          ],
          "bridge": "{ ...next(operator), day: before[0], after: after[0], operator: operator, interpolate: '${day} ${operator} ${after}' }",
          "check": [
            "day",
            "after"
          ]
        },
        {
          "id": "dateTimeSelector",
          "after": [
            "preposition"
          ],
          "before": [
            "verb"
          ],
          "convolution": true,
          "children": [
            "onDate_dates",
            "atTime",
            "date_dates"
          ],
          "bridge": "{ ...next(operator), date: after[0], time: after[1], interpolate: '${date} ${time}' }",
          "check": [
            "time",
            "date"
          ]
        }
      ],
      "semantics": [
        {
          "match": "({context, isA}) => context.evaluate && onOrIs('dayAfterDate', context)",
          "apply": "async ({context, isProcess, isTest, kms, isA, e}) => {\n            try {\n              const now = kms.time.api.now()\n              const date = afterOrIs('dayAfterDate', context)\n              const afterISO = (await e(date.after)).evalue\n              const day_ordinal = date.day.day_ordinal\n              const ordinal = date.day.ordinal.value\n              context.evalue = dateTimeSelectors_helpers.getNthWeekdayAfterDate(afterISO, day_ordinal, ordinal)\n            } catch ( e ) {\n              context.evalue = `Implement instatiate for this type of date. See the dateTimeSelectors KM ${where()}. ${e}`\n            }\n          }"
        },
        {
          "match": "({context, isA}) => context.evaluate && onOrIs('dayOfMonth', context)",
          "apply": "({context, isProcess, isTest, kms, isA}) => {\n            try {\n              const now = kms.time.api.now()\n              const date = onOrIs('dayOfMonth', context)\n              context.evalue = dateTimeSelectors_helpers.getNthDayOfMonth(removeDatesSuffix(date.day.value), date.day.ordinal.value || 1, removeDatesSuffix(date.month.value), now)\n            } catch ( e ) {\n              context.evalue = `Implement instatiate for this type of date. See the dateTimeSelectors KM ${where()}. ${e}`\n            }\n          }"
        },
        {
          "match": "({context, isA}) => {\n            if (!context.evaluate) {\n              return false\n            }\n            if (isA(context.marker, 'onDateValue_dates')) {\n              return true\n            }\n            if (isA(context.marker, 'dateTimeSelector')) {\n              return true\n            }\n          }",
          "apply": "({context, isProcess, isTest, kms, isA}) => {\n            context.evalue = instantiate(kms, isA, isProcess || isTest || context.isTest, context)\n          }"
        }
      ],
      "hierarchy": [
        [
          "day_dates",
          "orderable"
        ]
      ]
    }
  ],
  "resultss": [
    {
      "extraConfig": true,
      "operators": [
        "([dateTimeSelector] (onDate) (atTime))",
        "((day_dates/*) [dayOfMonth|of] (month_dates/*))",
        "((day_dates/*) [dayAfterDate|after] (afterDateValue_dates/*))"
      ],
      "bridges": [
        {
          "id": "dayOfMonth",
          "after": [
            "article"
          ],
          "isA": [
            "onDateValue_dates"
          ],
          "before": [
            "verb",
            "onDate_dates"
          ],
          "bridge": "{ ...next(operator), day: before[0], month: after[0], operator: operator, interpolate: '${day} ${operator} ${month}' }",
          "check": [
            "day",
            "month"
          ]
        },
        {
          "id": "dayAfterDate",
          "after": [
            "article",
            "monthDayYear_dates"
          ],
          "isA": [
            "onDateValue_dates"
          ],
          "before": [
            "verb",
            "afterDate_dates"
          ],
          "bridge": "{ ...next(operator), day: before[0], after: after[0], operator: operator, interpolate: '${day} ${operator} ${after}' }",
          "check": [
            "day",
            "after"
          ]
        },
        {
          "id": "dateTimeSelector",
          "after": [
            "preposition"
          ],
          "before": [
            "verb"
          ],
          "convolution": true,
          "children": [
            "onDate_dates",
            "atTime",
            "date_dates"
          ],
          "bridge": "{ ...next(operator), date: after[0], time: after[1], interpolate: '${date} ${time}' }",
          "check": [
            "time",
            "date"
          ]
        }
      ],
      "semantics": [
        {},
        {},
        {}
      ],
      "hierarchy": [
        [
          "day_dates",
          "orderable"
        ]
      ]
    }
  ],
  "fragments": [],
  "semantics": [],
  "associations": [],
  "summaries": [],
  "learned_contextual_priorities": []
}