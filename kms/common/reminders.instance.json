{
  "configs": [
    {
      "operators": [
        "([remind] (self/*) (*)*)",
        "([reminderTime|])",
        "([show] ([reminders]))",
        "([delete_reminders|delete,cancel] (number/*))"
      ],
      "bridges": [
        {
          "id": "remind",
          "isA": [
            "verb"
          ],
          "bridge": "{ ...next(operator), operator: operator, who: after[0], reminder: after[1], interpolate: '${operator} ${who} ${reminder}' }",
          "semantic": "async ({api, gsp, context}) => {\n            const text = await gsp(context.reminder.slice(1));\n            api.add({ text });\n          }"
        },
        {
          "id": "reminderTime",
          "children": [
            "day_dates",
            "month_dates"
          ]
        },
        {
          "id": "reminders",
          "isA": [
            "noun"
          ]
        },
        {
          "id": "show",
          "isA": [
            "verb"
          ],
          "bridge": "{ ...next(operator), operator: operator, reminders: after[0], interpolate: '${operator} ${reminders}' }",
          "semantic": "({context, api, verbatim}) => {\n            verbatim(api.show())\n          }"
        },
        {
          "id": "delete_reminders",
          "isA": [
            "verb"
          ],
          "bridge": "{ ...next(operator), operator: operator, reminders: after[0], interpolate: '${operator} ${reminders}' }",
          "semantic": "({context, api, verbatim}) => {\n            const s = api.delete_reminder(context.reminders.value)\n            if (s) {\n              verbatim(s)\n            }\n          }"
        }
      ]
    },
    {
      "apply": "({ask, api}) => {\n      ask([\n        {\n          where: where(),\n          oneShot: false,\n          onNevermind: ({verbatim, ...args}) => {\n            // this is cross km boundaries from the dialogues km to this one so the api if for dialogs.\n            // i need to get the one for fastfood here.\n            const api = args.kms.fastfood.api\n            const needsDrink = askAbout({ args, api })\n            for (const item of needsDrink) {\n              api.remove(item)\n            }\n          },\n\n          matchq: ({ api, context }) => api.askAbout().length > 0 && context.marker == 'controlEnd',\n          applyq: ({ api, context }) => {\n            context.cascade = false\n            const items = api.askAbout()\n            const item = items[0]\n            return 'When should I remind you to ' + item.text;\n          },\n\n          matchr: ({ isA, api, context }) => {\n            if (isA(context.marker, 'reminderTime') && api.askAbout().length > 0) {\n                return true\n            }\n            return false\n          },\n          applyr: ({ context, api }) => {\n            const items = api.askAbout()\n            api.update({ id: items[0].id, when: context })\n            // TODO check for is available for all modifications\n            /*\n            const needsDrink = askAbout(args)\n            const { api, context } = args\n            if (isMany(context)) {\n              let count = getCount(context) || Number.MAX_SAFE_INTEGER\n              for (const item of needsDrink) {\n                if (count < 1) {\n                  break\n                }\n                count -= 1\n                api.addDrink(item.item_id, { id: context.value })\n              }\n            } else {\n              const item_id = needsDrink[0].item_id\n              api.addDrink(item_id, { id: context.value })\n            }\n            */\n          }\n        },\n      ])\n    }"
    }
  ],
  "resultss": [
    {
      "extraConfig": true,
      "operators": [
        "([remind] (self/*) (*)*)",
        "([reminderTime|])",
        "([show] ([reminders]))",
        "([delete_reminders|delete,cancel] (number/*))"
      ],
      "bridges": [
        {
          "id": "remind",
          "isA": [
            "verb"
          ],
          "bridge": "{ ...next(operator), operator: operator, who: after[0], reminder: after[1], interpolate: '${operator} ${who} ${reminder}' }"
        },
        {
          "id": "reminderTime",
          "children": [
            "day_dates",
            "month_dates"
          ]
        },
        {
          "id": "reminders",
          "isA": [
            "noun"
          ]
        },
        {
          "id": "show",
          "isA": [
            "verb"
          ],
          "bridge": "{ ...next(operator), operator: operator, reminders: after[0], interpolate: '${operator} ${reminders}' }"
        },
        {
          "id": "delete_reminders",
          "isA": [
            "verb"
          ],
          "bridge": "{ ...next(operator), operator: operator, reminders: after[0], interpolate: '${operator} ${reminders}' }"
        }
      ]
    },
    {
      "apply": "({ask, api}) => {\n      ask([\n        {\n          where: where(),\n          oneShot: false,\n          onNevermind: ({verbatim, ...args}) => {\n            // this is cross km boundaries from the dialogues km to this one so the api if for dialogs.\n            // i need to get the one for fastfood here.\n            const api = args.kms.fastfood.api\n            const needsDrink = askAbout({ args, api })\n            for (const item of needsDrink) {\n              api.remove(item)\n            }\n          },\n\n          matchq: ({ api, context }) => api.askAbout().length > 0 && context.marker == 'controlEnd',\n          applyq: ({ api, context }) => {\n            context.cascade = false\n            const items = api.askAbout()\n            const item = items[0]\n            return 'When should I remind you to ' + item.text;\n          },\n\n          matchr: ({ isA, api, context }) => {\n            if (isA(context.marker, 'reminderTime') && api.askAbout().length > 0) {\n                return true\n            }\n            return false\n          },\n          applyr: ({ context, api }) => {\n            const items = api.askAbout()\n            api.update({ id: items[0].id, when: context })\n            // TODO check for is available for all modifications\n            /*\n            const needsDrink = askAbout(args)\n            const { api, context } = args\n            if (isMany(context)) {\n              let count = getCount(context) || Number.MAX_SAFE_INTEGER\n              for (const item of needsDrink) {\n                if (count < 1) {\n                  break\n                }\n                count -= 1\n                api.addDrink(item.item_id, { id: context.value })\n              }\n            } else {\n              const item_id = needsDrink[0].item_id\n              api.addDrink(item_id, { id: context.value })\n            }\n            */\n          }\n        },\n      ])\n    }"
    }
  ],
  "fragments": [],
  "semantics": [],
  "associations": [],
  "summaries": [],
  "learned_contextual_priorities": []
}